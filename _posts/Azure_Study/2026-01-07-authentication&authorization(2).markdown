---
layout: post
title: "[Azure] 인증(Authentication)과 인가(Authorization) (2): 동작 원리와 주요 방식"
date: 2026-01-07 09:00:00 +0900
tags: [Study, Identity, Governance]
---

지난 포스트 [**인증(Authentication)과 인가(Authorization) (1): 개념과 차이점**]({% post_url 2026-01-05-authentication&authorization(1) %})에서는 인증과 인가의 기본 개념과 차이점을 알아보았습니다.

> **(요약)**<br>
> 인증은 "누구인가?"<br>
> 인가는 "무엇을 할 수 있는가?"

이번 포스트에서는 인증과 인가가 실제 서비스에서 **어떤 흐름**(Flow)으로 동작하며, 현업에서 가장 많이 사용되는 **3가지 주요 인증 방식**들에 대해 정리해보겠습니다.

<br>

## 1. 인증과 인가의 기본 흐름 (Flow)

웹 서비스에서 사용자가 로그인 후 서비스를 이용할 때, 인증과 인가는 보통 다음과 같은 순차적 흐름을 따릅니다.

**1단계: 인증 (Authentication) - 신원 확인 및 증표 발급**

1.  **로그인 요청** (Client → Server): 사용자가 ID/Password를 서버에 제출합니다.
2.  **신원 확인** (Server 내부): 서버는 DB를 조회하여 사용자 정보가 일치하는지 검증합니다.
3.  **증표 발급** (Server 내부): 검증이 완료되면 서버는 **증표**(Token 또는 Session ID)를 생성합니다.
4.  **증표 전달** (Server → Client): 생성된 증표를 클라이언트에게 응답으로 보냅니다.

**2단계: 인가 (Authorization) - 권한 확인 및 자원 접근**

5.  **서비스 이용 요청** (Client → Server): 클라이언트는 데이터를 요청할 때, 앞서 받은 **증표**를 요청 헤더에 담아 함께 보냅니다.
6.  **권한 검증** (Server 내부): 서버는 증표의 유효성을 검사한 후, 해당 사용자가 요청한 자원에 대한 접근 권한이 있는지 확인합니다.
7.  **최종 응답** (Server → Client): 권한이 확인되면 서버는 요청받은 데이터를 클라이언트에 전송합니다.

<br>

## 2. 대표적인 인증 방식

"인증된 사용자임"을 증명하는 **증표**(Credential)를 어떻게 관리하느냐에 따라 인증 방식이 나뉩니다. 앞서 말했듯 흔히 쓰이는 3가지 주요 인증 방식을 살펴보겠습니다.

### 1. 세션 - 쿠키 (Session-Cookie) 방식
가장 전통적이고 현재까지도 많이 쓰이는 방식입니다. 핵심은 "서버가 사용자의 로그인 정보를 기억(Stateful)한다" 는 점입니다.

*   **상세 동작 원리**:
    1.  **로그인**: 사용자가 ID/PW를 제출하면 서버가 검증합니다.
    2.  **세션 생성**: 검증에 성공하면 서버는 고유한 `Session ID`를 생성하고, 이 ID와 연결된 사용자 정보를 서버 메모리나 별도 저장소(Redis, DB 등)에 저장합니다.
    3.  **쿠키 발급**: 생성된 `Session ID`를 브라우저에게 응답 헤더(`Set-Cookie`)로 전달합니다.
    4.  **요청 시 제출**: 브라우저는 이후 해당 서버로 요청을 보낼 때마다 쿠키에 저장된 `Session ID`를 자동으로 함께 보냅니다.
    5.  **검증**: 서버는 쿠키 속 `Session ID`로 저장소를 조회하여 "이 요청은 고객(Client)가 보낸 것"이라고 식별합니다.

*   **장점**:
    *   **보안 및 통제**: 서버가 세션 정보를 쥐고 있으므로, 의심스러운 접속이 발견되면 서버에서 해당 세션을 지워버려 **강제 로그아웃** 시킬 수 있습니다.
    *   **간편함**: 구현이 상대적으로 직관적이며, 데이터 노출 위험이 쿠키(Session ID)에 한정됩니다.

*   **단점**:
    *   **서버 부하 (Stateful)**: 접속자가 많아지면 모든 세션 정보를 메모리에 저장해야 하므로 서버 부하가 커집니다.
    *   **확장성(Scale-out) 이슈**: 서버를 여러 대(A, B, C)로 늘릴 경우, A서버에 로그인한 사용자가 B서버로 요청을 보내면 B서버는 세션 정보가 없어 로그인이 풀릴 수 있습니다. (이를 해결하기 위해 Sticky Session이나 Session Clustering 등이 필요합니다.)

![session flow](/images/26-01-07-session_flow.svg)

### 2. 토큰 기반 인증 (JWT - JSON Web Token)
최근 모바일 앱이나 MSA(Microservices Architecture) 환경에서 표준처럼 사용되는 방식입니다. 핵심은 **"서버가 기억하지 않고, 토큰 자체에 검증 정보를 담는다**(Stateless)"는 점입니다. 가장 대표적인 규격이 **JWT** (JSON Web Token)입니다.

#### **JWT의 3가지 핵심 구성요소**
JWT는 `.`(점)으로 구분된 세 부분으로 이루어져 있습니다. 헤더, 페이로드, 서명 순으로 구성됩니다.

```
Header.Payload.Signature
```

**1) Header (헤더)**
*   **역할**: 토큰의 타입과 암호화 알고리즘 정보를 담습니다.
*   **내용**: "이 토큰은 JWT이고, 서명에는 HS256 알고리즘을 썼어"라고 명시합니다.
    ```json
    {
      "alg": "HS256",
      "typ": "JWT"
    }
    ```

**2) Payload (페이로드)**
*   **역할**: 실제로 전달하려는 데이터(**Claims**)가 담기는 부분입니다.
*   **내용**: 사용자 ID(Subject), 토큰 발급자(Issuer), 만료 시간(Expiration) 등의 표준 정보와, "관리자 권한(Role)" 같은 커스텀 정보를 담을 수 있습니다.
*   **주의**: 이 부분은 **단순히 Base64Url로 인코딩**되어 있어 누구나 쉽게 복호화하여 볼 수 있습니다. 따라서 **비밀번호나 주민번호 같은 민감한 정보는 절대 담아서는 안 됩니다.**
    ```json
    {
      "sub": "user123",
      "name": "Hong Gil Dong",
      "iat": 1616239022, 
      "exp": 1616242622
    }
    ```

**3) Signature (서명)**
*   **역할**: 토큰의 **무결성**(위변조 여부)을 검증하는 핵심 부분입니다.
*   **원리**: `Header`와 `Payload`의 내용을 합친 뒤, 서버만 알고 있는 **비밀 키**(Secret Key)를 이용해 암호화합니다.
*   **검증**: 만약 누군가 Payload의 내용(예: "일반 사용자" -> "관리자")을 몰래 수정하더라도, 비밀 키가 없으므로 올바른 서명 값을 만들어낼 수 없습니다. 서버는 서명이 맞지 않으면 즉시 요청을 거부합니다.

---

*   **동작 흐름**:
    1.  **발급**: 로그인 성공 시 서버는 위 3가지 요소를 조합하고 서명한 **JWT**를 생성해 클라이언트에 줍니다.
    2.  **저장**: 클라이언트는 이 토큰을 저장(Local Storage, Cookie 등)합니다.
    3.  **사용**: 요청 시 HTTP 헤더(`Authorization: Bearer <Token>`)에 담아 보냅니다.
    4.  **검증**: 서버는 DB를 뒤질 필요 없이, **서명(Signature)만 계산**하여 유효성을 판단합니다.

*   **장점**:
    *   **확장성(Stateless)**: 서버가 상태를 저장하지 않으므로 서버를 무한히 늘려도(Scale-out) 별도의 동기화 처리가 필요 없습니다. 어떤 서버든 서명 키만 알면 검증 가능합니다.
    *   **유연성**: 웹, 앱 등 다양한 클라이언트 환경에서 공통적으로 사용하기 좋습니다.

*   **단점 및 보완**:
    *   **취소 불가**: 한 번 발급된 토큰은 유효기간이 끝날 때까지 서버가 강제로 만료시킬 수 없습니다(탈취 시 위험).
    *   **트래픽**: 토큰에 많은 정보를 담으면 길이가 길어져 네트워크 트래픽이 늘어날 수 있습니다.
    *   **보완책**: 수명이 짧은 **Access Token**과, 재발급을 위한 **Refresh Token**을 함께 사용하는 전략이 일반적입니다.

<br>

**세션(Session) vs 토큰(Token) 비교**

| 구분 | &nbsp; 세션 (Session) 방식 | &nbsp; 토큰 (Token/JWT) 방식 |
| :--- | :--- | :--- |
| **저장소** | &nbsp; 서버 메모리/DB에 정보 저장 | &nbsp; 클라이언트(브라우저 등)에 정보 저장 |
| **인증 증표** | &nbsp; Session ID (단순한 문자열) | &nbsp; JWT (데이터를 포함한 암호화된 문자열) |
| **장점** | &nbsp; 서버가 로그아웃 등을 직접 제어 가능,<br> &nbsp; 보안 사고 시 세션 즉시 만료 가능 | &nbsp; 서버 부하가 적고 확장이 쉬움 (Stateless),<br> &nbsp; 서버 분산 환경(MSA)에 유리 |
| **단점** | &nbsp; **서버 부하**: 동접자 증가 시 메모리/DB 부담<br> &nbsp; **확장성 저하**: 세션 동기화 설정 복잡 | &nbsp; **취소 어려움**: 토큰 탈취 시 강제 만료 불가<br> &nbsp; **데이터 크기**: 큰 페이로드로 네트워크 부하 증가 |

<br>

### 3. OAuth 2.0 (Open Authorization)
"구글로 로그인", "카카오 로그인"과 같이 **외부 서비스의 계정을 빌려 인증**하는 개방형 표준 프로토콜입니다.

#### **핵심 개념**
서비스(Client Application)가 사용자(Client)의 비밀번호를 직접 받지 않고, 검증된 외부 플랫폼(Google, Kakao, Facebook 등)에 인증을 위임한 뒤 **권한 증표**(Access Token)만 받아오는 방식입니다.

예를 들어, 어떤 앱에서 "카카오로 로그인" 버튼을 클릭하면:
*   앱이 직접 카카오 비밀번호를 받지 않고,
*   카카오 인증 서버가 사용자 신원을 확인한 뒤,
*   앱은 "이 사용자가 인증됨"을 증명하는 **토큰**만 받아서 서비스를 제공합니다.

#### **주요 구성요소**

OAuth 2.0은 4개의 주요 구성요소로 이루어져 있습니다:

1.  **Client (클라이언트)**  
    일반 사용자 (서비스 이용자). 리소스의 실제 소유자로, 자신의 정보에 대한 접근 권한을 부여할 수 있습니다.

2.  **Client Application (클라이언트 애플리케이션)**  
    사용자가 이용하고자 하는 웹/앱 서비스. 사용자 대신 리소스에 접근하려는 애플리케이션입니다.  
    *(예: "카카오 로그인"을 구현한 쇼핑몰 앱)*

3.  **Authorization Server (인증 서버)**  
    사용자의 신원을 확인하고, 사용자의 동의를 받아 **Access Token**을 발급하는 서버입니다.  
    *(예: 카카오 인증 서버, Google OAuth 서버)*

4.  **Resource Server (리소스 서버)**  
    사용자의 실제 정보(프로필, 이메일, 친구 목록 등)를 보관하고 있는 서버입니다. Access Token을 검증한 뒤 요청된 리소스를 제공합니다.  
    *(예: 카카오 API 서버, Google API 서버)*

> **Note**: Authorization Server와 Resource Server는 물리적으로 같은 서버일 수도 있고, 분리되어 있을 수도 있습니다.

<br>

#### **동작 흐름 (Authorization Code Grant)**

가장 많이 사용되는 **Authorization Code 방식**의 흐름은 다음과 같습니다:

1.  **로그인 요청**: 사용자가 Client Application에서 "카카오로 로그인" 버튼을 클릭합니다.

2.  **인증 페이지 리디렉션**: Client Application은 사용자를 Authorization Server의 로그인 페이지로 리디렉션합니다.  
    *(`client_id`, `redirect_uri`, `scope` 등의 파라미터를 함께 전달)*

3.  **사용자 로그인 및 동의**: 사용자가 Authorization Server에서 직접 로그인하고, Client Application이 요청한 권한(scope)에 동의합니다.  
    *(예: "이 앱이 내 이메일과 프로필 정보를 사용하는 것에 동의합니다")*

4.  **Authorization Code 발급**: Authorization Server는 사용자를 다시 Client Application으로 리디렉션하며, **Authorization Code**(임시 인증 코드)를 함께 전달합니다.

5.  **Access Token 요청**: Client Application은 받은 Authorization Code를 Authorization Server에 제출하며 **Access Token**을 요청합니다.  
    *(이 과정은 서버 간 통신으로 진행되어 보안성이 높습니다)*

6.  **Access Token 발급**: Authorization Server는 Code를 검증한 후 **Access Token** (그리고 선택적으로 **Refresh Token**)을 발급합니다.

7.  **리소스 접근**: Client Application은 Access Token을 사용하여 Resource Server에 사용자 정보를 요청합니다.

8.  **정보 제공**: Resource Server는 Token을 검증한 후 요청된 사용자 정보를 Client Application에게 제공합니다.

#### **장점**
*   **보안성**: 사용자의 실제 비밀번호를 제3자 앱에 노출하지 않습니다.
*   **편의성**: 사용자는 별도의 회원가입 없이 기존 계정으로 빠르게 서비스를 이용할 수 있습니다.
*   **세밀한 권한 제어**: Scope를 통해 필요한 권한만 선택적으로 요청할 수 있습니다.
*   **책임 분산**: 인증/보안 책임의 상당 부분을 대형 플랫폼에 위임할 수 있습니다.

#### **단점**
*   **외부 의존성**: 외부 플랫폼(카카오, 구글 등)의 서비스 장애 시 우리 서비스의 로그인도 영향을 받습니다.
*   **구현 복잡도**: 세션 방식보다 초기 구현이 복잡하고, OAuth 프로토콜에 대한 이해가 필요합니다.
*   **개인정보 정책**: 제3자 플랫폼과 데이터를 공유하므로, 개인정보 처리 방침을 명확히 해야 합니다.


![oauth flow](/images/26-01-07-oauth_flow.svg)
> 출처: https://docs.secureauth.com/ciam/en/oauth-2-0-authorization-code-flow.html

<br>

## 3. Azure의 인증/인가 서비스

이러한 인증/인가 서비스는 Azure Cloud 환경 내에 별도의 서비스들로 구현이 되어있습니다. 다음 포스트에서는 **Azure Identity**의 핵심 서비스들을 깊이 있게 다룰 예정입니다.

미리 핵심 키워드만 간단히 살펴보겠습니다.

1.  **Microsoft Entra ID (구 Azure AD)**
    *   Azure의 모든 인증과 인가를 관장하는 **클라우드 기반 자격 증명(Identity) 관리** 서비스입니다.
    *   사용자, 그룹, 애플리케이션의 ID를 중앙에서 통합 관리합니다.

2.  **Azure RBAC (역할 기반 액세스 제어) / IAM**
    *   **"누가(Who) 무엇(Resource)에 대해 어떤 작업(Action)을 할 수 있는가?"**를 제어하는 Azure의 핵심 **인가(Authorization)** 시스템입니다.
    *   '소유자(Owner)', '기여자(Contributor)', '독자(Reader)' 등 역할을 부여하여 리소스 접근 권한을 세밀하게 제어합니다.

3.  **서비스 주체 (Service Principal) & 관리 ID (Managed Identities)**
    *   사람이 아닌 **"애플리케이션이나 클라우드 리소스를 위한 신분증"**입니다.
    *   **Service Principal**: 앱이 Azure 리소스에 접근할 수 있도록 권한을 위임받은 ID입니다.
    *   **Managed Identity**: Azure 리소스(VM, App Service 등)가 자동으로 발급받는 ID로, 코드에 비밀번호를 저장할 필요 없이 안전하게 다른 리소스에 접근하게 해줍니다.

<br>

이어지는 세번째 포스트에서는 **Azure 환경에서의 인증/인가 서비스**에 대해 알아보겠습니다.