---
layout: post
title: "인증(Authentication)과 인가(Authorization) (2): 동작 원리와 주요 방식"
date: 2026-01-07 09:00:00 +0900
tags: [Study, Identity, Governance]
categories: Azure_Study
---

지난 포스트 [**인증(Authentication)과 인가(Authorization) (1): 개념과 차이점**]({% post_url 2026-01-05-authentication&authorization(1) %})에서는 두 개념의 **본질적인 차이**에 대해 알아보았습니다.

> **(요약)**<br>
> 인증은 "누구인가?"<br>
> 인가는 "무엇을 할 수 있는가?"

이번 포스트에서는 인증과 인가가 실제 서비스에서 **어떤 흐름(Flow)**으로 동작하며, 현업에서 가장 많이 사용되는 **주요 인증 방식**들에 대해 정리해보겠습니다.

<br>

## 1. 인증과 인가의 기본 흐름 (Flow)

웹 서비스에서 인증과 인가는 보통 다음과 같은 순서로 일어납니다.

1.  **로그인 요청** (ID/PW 주입) `[인증]`
2.  **신원 확인 요청 및 증표 발급 요청** `[인증]`
3.  **신원 확인 완료 및 증표(Token) 발급** `[인증]`
4.  **증표(Token/Session) 전달** `[인증]`
5.  **서비스 이용 요청** (Token 제출) `[인가]`
6.  **권한 확인** (Token 유효성 검사 및 인가 처리) `[인가]`
7.  **최종 응답** (데이터 제공) `[인가]`

<br>

## 2. 대표적인 인증 방식

"인증된 사용자임"을 증명하는 **증표(Credential)**를 어떻게 관리하느냐에 따라 인증 방식이 나뉩니다. 가장 널리 쓰이는 방식을 상세히 살펴보겠습니다.

### 1. 세션 - 쿠키 (Session-Cookie) 방식
가장 전통적이고 현재까지도 많이 쓰이는 방식입니다. 핵심은 **"서버가 사용자의 로그인 정보를 기억(Stateful)한다"**는 점입니다.

*   **상세 동작 원리**:
    1.  **로그인**: 사용자가 ID/PW를 제출하면 서버가 검증합니다.
    2.  **세션 생성**: 검증에 성공하면 서버는 고유한 **`Session ID`**를 생성하고, 이 ID와 연결된 사용자 정보를 서버 메모리나 별도 저장소(Redis, DB 등)에 저장합니다.
    3.  **쿠키 발급**: 생성된 `Session ID`를 브라우저에게 응답 헤더(`Set-Cookie`)로 전달합니다.
    4.  **요청 시 제출**: 브라우저는 이후 해당 서버로 요청을 보낼 때마다 쿠키에 저장된 `Session ID`를 자동으로 함께 보냅니다.
    5.  **검증**: 서버는 쿠키 속 `Session ID`로 저장소를 조회하여 "아, 이 요청은 철수(User A)가 보낸 것이구나"라고 식별합니다.

*   **장점**:
    *   **보안 및 통제**: 서버가 세션 정보를 쥐고 있으므로, 의심스러운 접속이 발견되면 서버에서 해당 세션을 지워버려 **강제 로그아웃** 시킬 수 있습니다.
    *   **간편함**: 구현이 상대적으로 직관적이며, 데이터 노출 위험이 쿠키(Session ID)에 한정됩니다.

*   **단점**:
    *   **서버 부하 (Stateful)**: 접속자가 많아지면 모든 세션 정보를 메모리에 저장해야 하므로 서버 부하가 커집니다.
    *   **확장성(Scale-out) 이슈**: 서버를 여러 대(A, B, C)로 늘릴 경우, A서버에 로그인한 사용자가 B서버로 요청을 보내면 B서버는 세션 정보가 없어 로그인이 풀릴 수 있습니다. (이를 해결하기 위해 Sticky Session이나 Session Clustering 등이 필요합니다.)

![session flow](/images/session_flow.svg)

### 2. 토큰 기반 인증 (JWT - JSON Web Token)
최근 모바일 앱이나 MSA(Microservices Architecture) 환경에서 표준처럼 사용되는 방식입니다. 핵심은 **"서버가 기억하지 않고, 토큰 자체에 검증 정보를 담는다(Stateless)"**는 점입니다. 가장 대표적인 규격이 **JWT (JSON Web Token)**입니다.

#### **JWT의 3가지 핵심 구성요소**
JWT는 `.`(점)으로 구분된 세 부분으로 이루어져 있습니다: `Header.Payload.Signature`

**1) Header (헤더)**
*   **역할**: 토큰의 타입과 암호화 알고리즘 정보를 담습니다.
*   **내용**: "이 토큰은 JWT이고, 서명에는 HS256 알고리즘을 썼어"라고 명시합니다.
    ```json
    {
      "alg": "HS256",
      "typ": "JWT"
    }
    ```

**2) Payload (페이로드)**
*   **역할**: 실제로 전달하려는 데이터(**Claims**)가 담기는 부분입니다.
*   **내용**: 사용자 ID(Subject), 토큰 발급자(Issuer), 만료 시간(Expiration) 등의 표준 정보와, "관리자 권한(Role)" 같은 커스텀 정보를 담을 수 있습니다.
*   **주의**: 이 부분은 **단순히 Base64Url로 인코딩**되어 있어 누구나 쉽게 복호화하여 볼 수 있습니다. 따라서 **비밀번호나 주민번호 같은 민감한 정보는 절대 담아서는 안 됩니다.**
    ```json
    {
      "sub": "user123",
      "name": "Hong Gil Dong",
      "iat": 1616239022, 
      "exp": 1616242622
    }
    ```

**3) Signature (서명)**
*   **역할**: 토큰의 **무결성(위변조 여부)**을 검증하는 핵심 부분입니다.
*   **원리**: `Header`와 `Payload`의 내용을 합친 뒤, 서버만 알고 있는 **비밀 키(Secret Key)**를 이용해 암호화합니다.
*   **검증**: 만약 누군가 Payload의 내용(예: "일반 사용자" -> "관리자")을 몰래 수정하더라도, 비밀 키가 없으므로 올바른 서명 값을 만들어낼 수 없습니다. 서버는 서명이 맞지 않으면 즉시 요청을 거부합니다.

---

*   **동작 흐름**:
    1.  **발급**: 로그인 성공 시 서버는 위 3가지 요소를 조합하고 서명한 **JWT**를 생성해 클라이언트에 줍니다.
    2.  **저장**: 클라이언트는 이 토큰을 저장(Local Storage, Cookie 등)합니다.
    3.  **사용**: 요청 시 HTTP 헤더(`Authorization: Bearer <Token>`)에 담아 보냅니다.
    4.  **검증**: 서버는 DB를 뒤질 필요 없이, **서명(Signature)만 계산**하여 유효성을 판단합니다.

*   **장점**:
    *   **확장성(Stateless)**: 서버가 상태를 저장하지 않으므로 서버를 무한히 늘려도(Scale-out) 별도의 동기화 처리가 필요 없습니다. 어떤 서버든 서명 키만 알면 검증 가능합니다.
    *   **유연성**: 웹, 앱 등 다양한 클라이언트 환경에서 공통적으로 사용하기 좋습니다.

*   **단점 및 보완**:
    *   **취소 불가**: 한 번 발급된 토큰은 유효기간이 끝날 때까지 서버가 강제로 만료시킬 수 없습니다(탈취 시 위험).
    *   **트래픽**: 토큰에 많은 정보를 담으면 길이가 길어져 네트워크 트래픽이 늘어날 수 있습니다.
    *   **보완책**: 수명이 짧은 **Access Token**과, 재발급을 위한 **Refresh Token**을 함께 사용하는 전략이 일반적입니다.

<br>

> **(참고) 세션(Session) vs 토큰(Token) 비교**
>
> 두 방식 모두 "인증된 사용자임을 증명"하는 용도지만, 저장 위치와 방식에 차이가 있습니다.
>
> | 구분 | &nbsp; 세션 (Session) 방식 | &nbsp; 토큰 (Token/JWT) 방식 |
> | :--- | :--- | :--- |
> | **저장소** | &nbsp; 서버 메모리/DB에 정보 저장 | &nbsp; 클라이언트(브라우저 등)에 정보 저장 |
> | **인증 증표** | &nbsp; Session ID (단순한 문자열) | &nbsp; JWT (데이터를 포함한 암호화된 문자열) |
> | **장점** | &nbsp; 서버가 로그아웃 등을 직접 제어 가능,<br>보안 사고 시 세션 즉시 만료 가능 | &nbsp; 서버 부하가 적고 확장이 쉬움 (Stateless),<br>서버 분산 환경(MSA)에 유리 |
> | **단점** | &nbsp; **서버 부하**: 동접자 증가 시 메모리/DB 부담<br>**확장성 저하**: 세션 동기화 설정 복잡 | &nbsp; **취소 어려움**: 토큰 탈취 시 강제 만료 불가<br>**데이터 크기**: 큰 페이로드로 네트워크 부하 증가 |

<br>

### 3. OAuth 2.0 (Open Authorization)
"구글로 로그인", "카카오 로그인"과 같이 **외부 서비스의 계정을 빌려 인증**하는 개방형 표준 프로토콜입니다.

*   **핵심 개념**: 내 서비스(Client)가 사용자의 비밀번호를 직접 받지 않고, 검증된 플랫폼(Google, Facebook 등)에 인증을 위임한 뒤 **권한 증표(Access Token)**만 받아오는 방식입니다.
*   **주요 구성요소**:
    1.  **Resource Owner**: 일반 사용자 (서비스 이용자).
    2.  **Client**: 우리가 만드는 웹/앱 서비스.
    3.  **Authorization Server**: 인증을 담당하고 토큰을 발급해주는 서버 (예: 카카오 인증 서버).
    4.  **Resource Server**: 사용자의 실제 정보(이름, 이메일 등)를 가지고 있는 서버 (예: 카카오 API 서버).

*   **장점**: 보안 책임의 일부를 대형 플랫폼에 위임할 수 있고, 사용자는 별도 회원가입 없이 서비스를 이용할 수 있어 진입 장벽이 낮아집니다.


![oauth flow](/images/26-01-07-oauth_flow.svg)
> 출처: https://docs.secureauth.com/ciam/en/oauth-2-0-authorization-code-flow.html

<br>

## 3. Azure의 인증/인가 서비스

Cloud 환경, 특히 Azure를 사용한다면 이러한 인증 시스템을 직접 밑바닥부터 구축할 필요 없이 제공되는 서비스를 활용할 수 있습니다. 다음 포스트에서는 **Azure Identity**의 핵심 서비스들을 깊이 있게 다룰 예정입니다.

미리 핵심 키워드만 간단히 살펴보겠습니다.

1.  **Microsoft Entra ID (구 Azure AD)**
    *   Azure의 기본이자 핵심인 클라우드 기반 **ID 및 액세스 관리(IAM)** 서비스입니다.
    *   직원들의 사내 앱 접근 제어부터 SaaS 애플리케이션 통합까지 담당합니다.

2.  **Azure AD B2C (Business to Consumer)**
    *   내 서비스의 **고객(일반 사용자)**을 위한 인증 솔루션입니다.
    *   회원가입, 로그인, 그리고 "소셜 로그인(페이스북, 구글 등)" 기능을 손쉽게 붙일 수 있게 해줍니다.

3.  **관리 ID (Managed Identities)**
    *   **"서버(리소스)를 위한 신분증"**입니다.
    *   개발자가 소스 코드에 비밀번호나 키(Credential)를 하드코딩하지 않고도, Azure 서비스 간(예: App Service가 SQL DB에 접근) 안전하게 인증할 수 있게 해줍니다.

<br>

이어지는 세번째 포스트에서는 **Azure 환경에서 이를 어떻게 실제로 구현하고 활용하는지** 본격적으로 알아보겠습니다.