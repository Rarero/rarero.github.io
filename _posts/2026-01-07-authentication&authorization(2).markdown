---
layout: post
title: "인증(Authentication)과 인가(Authorization) (2): 동작 원리와 주요 방식"
date: 2026-01-07 09:00:00 +0900
tags: [Study, Identity, Governance]
categories: Azure_Study
---

지난 포스트 [**인증(Authentication)과 인가(Authorization) (1): 개념과 차이점**]({% post_url 2026-01-05-인증과인가 %})에서는 두 개념의 **본질적인 차이**에 대해 알아보았습니다.

> **(요약)**<br>
> 인증은 "누구인가?"<br>
> 인가는 "무엇을 할 수 있는가?"

이번 포스트에서는 인증과 인가가 실제 서비스에서 **어떤 흐름(Flow)**으로 동작하며, 현업에서 가장 많이 사용되는 **주요 인증 방식**들에 대해 정리해보겠습니다.

<br>

## 1. 인증과 인가의 기본 흐름 (Flow)

웹 서비스에서 인증과 인가는 보통 다음과 같은 순서로 일어납니다.

1.  **로그인 요청** (ID/PW 주입) `[인증]`
2.  **신원 확인 요청 및 증표 발급 요청** `[인증]`
3.  **신원 확인 완료 및 증표(Token) 발급** `[인증]`
4.  **증표(Token/Session) 전달** `[인증]`
5.  **서비스 이용 요청** (Token 제출) `[인가]`
6.  **권한 확인** (Token 유효성 검사 및 인가 처리) `[인가]`
7.  **최종 응답** (데이터 제공) `[인가]`

![authentication&authorization flow](../images/authentication&authorization_flow.drawio.png)

<br>

## 2. 대표적인 인증 방식

"인증된 사용자임"을 증명하는 **증표**를 어떻게 관리하느냐에 따라 인증 방식이 나뉩니다. 가장 널리 쓰이는 방식을 살펴보겠습니다.

### 1. 세션 - 쿠키 (Session-Cookie) 방식
가장 전통적인 방식입니다. **서버가 사용자의 로그인 정보를 기억(저장)**합니다.

*   **동작**:
    1.  서버는 로그인 성공 시 `Session ID`를 생성하여 서버 메모리나 DB(Redis 등)에 저장합니다.
    2.  이 `Session ID`를 브라우저의 **쿠키(Cookie)**에 담아 보냅니다.
    3.  브라우저는 이후 요청마다 쿠키를 자동으로 포함시켜 보냅니다.
*   **장점**: 보안성이 비교적 높고, 서버에서 강제 로그아웃 등 통제가 쉽습니다.
*   **단점**: 서버에 상태를 저장하므로(Stateful), 사용자가 많아지면 메모리 부하가 생기거나 분산 서버 환경(Scale-out)에서 세션 동기화 처리가 필요합니다.

### 2. 토큰 기반 인증 (JWT - JSON Web Token)
최근 모바일 앱이나 MSA(Microservices Architecture) 환경에서 표준처럼 사용되는 방식입니다. **서버가 기억하지 않고, 토큰 자체에 정보를 담습니다.**

*   **동작**:
    1.  서버는 로그인 성공 시 사용자의 정보와 위변조 방지 서명을 포함한 **JWT(문자열)**를 생성하여 클라이언트에 줍니다.
    2.  클라이언트는 이 토큰을 저장(Local Storage 등)해두고, 요청 시 헤더(`Authorization: Bearer <Token>`)에 담아 보냅니다.
    3.  서버는 토큰의 서명(Signature)만 검증하여 유효성을 판단합니다 (DB 조회 X).
*   **장점**: **Stateless(무상태)**. 서버가 세션을 유지할 필요가 없어 확장성이 매우 뛰어납니다.
*   **단점**: 한 번 발급된 토큰은 유효기간 만료 전까지 강제로 폐기하기 어렵습니다 (탈취 시 위험). 이를 보완하기 위해 Access Token(짧은 수명)과 Refresh Token을 함께 사용합니다.

<br>

> **(참고) 세션(Session) vs 토큰(Token) 비교**
>
> 두 방식 모두 "인증된 사용자임을 증명"하는 용도지만, 저장 위치와 방식에 차이가 있습니다.

| 구분 | 세션 (Session) 방식 | 토큰 (Token/JWT) 방식 |
| :--- | :--- | :--- |
| **저장소** | 서버 메모리/DB에 정보 저장 | 클라이언트(브라우저 등)에 정보 저장 |
| **인증 증표** | Session ID (단순한 문자열) | JWT (데이터를 포함한 암호화된 문자열) |
| **장점** | 서버가 로그아웃 등을 직접 제어 가능,<br>보안 사고 시 세션 즉시 만료 가능 | 서버 부하가 적고 확장이 쉬움 (Stateless),<br>서버 분산 환경(MSA)에 유리 |
| **단점** | **서버 부하**: 동접자 증가 시 메모리/DB 부담<br>**확장성 저하**: 세션 동기화 설정 복잡 | **취소 어려움**: 토큰 탈취 시 강제 만료 불가<br>**데이터 크기**: 큰 페이로드로 네트워크 부하 증가 |

<br>

### 3. OAuth 2.0 (Open Authorization)
"구글로 로그인", "카카오 로그인"과 같이 **외부 서비스의 계정을 빌려 인증**하는 방식입니다.

*   **동작**: 서비스가 직접 사용자의 비밀번호를 받지 않고, 검증된 인증 제공자(Identity Provider, 예: Google, Facebook)에게 인증을 위임하고 **접근 토큰(Access Token)**을 받아옵니다.
*   **특징**: 보안 책임의 일부를 대형 플랫폼에 위임할 수 있고, 사용자는 회원가입의 번거로움을 덜 수 있습니다.

<br>

## 3. Azure의 인증/인가 서비스

Cloud 환경, 특히 Azure를 사용한다면 이러한 인증 시스템을 직접 밑바닥부터 구축할 필요 없이 제공되는 서비스를 활용할 수 있습니다. 다음 포스트에서는 **Azure Identity**의 핵심 서비스들을 깊이 있게 다룰 예정입니다.

미리 핵심 키워드만 간단히 살펴보겠습니다.

1.  **Microsoft Entra ID (구 Azure AD)**
    *   Azure의 기본이자 핵심인 클라우드 기반 **ID 및 액세스 관리(IAM)** 서비스입니다.
    *   직원들의 사내 앱 접근 제어부터 SaaS 애플리케이션 통합까지 담당합니다.

2.  **Azure AD B2C (Business to Consumer)**
    *   내 서비스의 **고객(일반 사용자)**을 위한 인증 솔루션입니다.
    *   회원가입, 로그인, 그리고 "소셜 로그인(페이스북, 구글 등)" 기능을 손쉽게 붙일 수 있게 해줍니다.

3.  **관리 ID (Managed Identities)**
    *   **"서버(리소스)를 위한 신분증"**입니다.
    *   개발자가 소스 코드에 비밀번호나 키(Credential)를 하드코딩하지 않고도, Azure 서비스 간(예: App Service가 SQL DB에 접근) 안전하게 인증할 수 있게 해줍니다.

<br>

이어지는 세번째 포스트에서는 **Azure 환경에서 이를 어떻게 실제로 구현하고 활용하는지** 본격적으로 알아보겠습니다.